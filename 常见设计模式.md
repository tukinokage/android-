# 1.单例模式 

懒汉式单例、饿汉式单例。 
饿汉式:
```java
public class StaticA  {
  public static final StaticA  sInstance = new StaticA()
  private StaticA () {
  }
}
```

优点：

- 实现简单
- 线程安全，因为其在类加载时就进行了初始化，虚拟机内部保证其线程安全，保证对常量/静态变量只进行一次初始化

缺点：

- 在类加载时就创建了静态对象，实际上可能不会用到，所以对资源来说是浪费了，同时时类的初始化变慢，性能上并不是很好
- 
### 饿汉模式：
```java
public class SingleA  {
    private static sInstance;
    
    private SingleA() {
    }
    
    public static SingleA getInstance() {
        if (sInstance == null) {
            sInstance  = new SingleA()
        }
        return sInstance;
    }
}
```
### 懒汉同步方法式
```kotlin
class SingleB {
    companion object {
        var sInstance: SingleB? = null

        @Synchronized
        fun getInstance(): SingleB? {
            if (sInstance == null) {
                sInstance = SingleB()
            }
            return sInstance
        }
    }
}
```
```java
public class SingleB {
    private static SingleB sInstance;
  
    private SingleB() {
    }
    
    public static synchronized SingleB getInstance() {
        if (sInstance == null) {
            sInstance = new SingleB();
        }
        return sInstance;
    }
}
```
- 延迟到使用时才进行初始化，提高了类加载的性能
- 对方法使用了同步锁synchronized，保证了线程安全

缺点：

- synchronized应用在方法上，所有是对整个方法加了锁，所以性能上稍差。因为只要调用该方法就会上锁。

### 懒汉同步块式(推荐)

与第3中的方式差不多，不同的是同步锁应用在方法的内部语句块中：
```kotlin
class SingleC {
    companion object {
        val sIntance by lazy(LazyThreadSafetyMode.SYNCHRONIZED) {
            SingleC()
        }
    }
}
```

```java
public SingleC{
	private static SingleC instance;
	public SingleC getInstance(){
		if(instance == null){
			synchronized(SingleC.class){
				if(instance == null){
					 instance = new SingleC();
				}
			}
		}else{
			return instance;
		}
	}
}

```
  
  优点：

- 延迟到使用时才进行初始化，提高了类加载的性能
- 在创建对象的语句块中使用了同步锁synchronized，保证线程安全的同时，降低了锁的作用范围

缺点：

- 需要1-2次的空判断

# 2.工厂模式

# 3.观察者模式

# 4.适配器模式

# 5.代理模式

静态，动态

# 6.职责链模式

# 7.享元模式

# 8.装饰器模式