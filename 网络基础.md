# 1.网络基础

## 1.网络分层

除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议，它们之间的对应关系如下图所示：

tcp/ip协议族：应用层，[传输层]，网络层，数据链路层，物理层

osi七层协议 [ 应用，表，会]，传，网，数，物，
巧记:  应用表示会话, 传输网络和链路，还有 物理


下面是协议层从底层至顶层的一个模型图：

![img](https://images2015.cnblogs.com/blog/983980/201611/983980-20161121173924409-1128983178.png)

 

![img](1538030296-7490-20150904094019903-1923900106.jpg)


表示层一般是加密解密，
会话层管理着网络连接事件顺序和流程的启动和关闭
## 2. **什么是URL？**

**统一资源定位符**（Uniform Resource Locator），是因特网上标准的资源地址。URL格式主要分为三个部分：

1、**协议**，如Http、Https(HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 [TCP](https://baike.baidu.com/item/TCP/33012) 之间） )。

2、**存有该资源的IP地址**，有时候也包括端口号。如：192.168.1.112（现在基本使用域名代替，如：www.baidu.com）

3、**主机资源的具体地址**。如文件和目录名。如：index.jsp或aaa.doc

1和2之间用“://”隔开，2和3用“/”分开。1和2是不可缺少的，3是可以缺少的。
## 3.  TCP/IP/UDP

.说一说 HTTPS、UDP、Socket 之间的区别？

参考答案：

TCP(Transmission Control Protocol,传输控制协议)与UDP(User Data Protocol,用户数据协议)是互联网传输数据较为常用的协议，我们熟知的HTTP就是基于TCP的.

而HTTPS就是HTTP 加上SSL的加密方式：

UDP是非面向连接的协议，发送数据时不管对方状态直接发送，无需建立连接，如同，对面在不在线无所谓. 域名mDNS就是通过UDP协议。部分流媒体协议如：RTP

Socket不属于协议范畴，别名套接字通过调用Socket，才能使用TCP/IP协议，Socket连接是长连接，理论上客户端和服务器端一旦建立连接将不会主动断开此连接。Socket连接属于请求-响应形式，服务端可主动将消息推送给客户端。

Socket是操作系统提供的一套对TCP的抽象操作的api，隐藏了TCP链接的细节。

socket常见操作：
new Socket
accpet

# 2.HTTP

**超文本协议 ，是互联网上应用最为广泛的一种网络协议 ，TCP/IP协议族的一个应用层的协议。**

**Https(HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 [TCP](https://baike.baidu.com/item/TCP/33012) 之间） , 采用非对称密钥)。**



- 1、支持客户端/服务器模式：就是客户端请求，服务器做出响应。

- 2、简单快速：客户端向服务器请求服务时，是需要传入请求方法和路径。请求方法常用的有GET、POST。每种方法都规定了客户端与服务器联系的类型不同。

- 3、**灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。**

- 4、**无连接：无连接的含义就是限制每次连接只处理一个请求。服务器处理完客户端的请求，并收到客户端的应答之后，即立即断开连接。**

- 5、无状态：HTTP协议是无状态的协议。无状态就是指协议对于事务的处理是没有记忆能力的。缺少状态就意味着如果后续处理需要前面的信息，则必须重新传送，这样会导致每次连接传送的数据量大。另一方面，在服务器不需要先前信息时，它的应答就会较快。

原文链接：https://blog.csdn.net/u014544193/article/details/49849843

## 2.1 Http版本对比

- 1.0协议，客户端与web服务器建立连接后，只能获得一个web资源！（资源静态，动态资源 ---servlet等等）
- **1.1协议，允许客户端与web服务器建立连接后，在一个连接上获取多个web资源！**链接复用
	- ==通过Cookie/Session技术HTTP/1.1持久连接（HTTP keep-alive）方法，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接HTTPS特点==
- **2.0 协议，**protobuff数据格式二进制。1.0用的还是文本。**
	- 多路复用 (Multiplexing) / 连接共享**
		在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制，超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一。
		
		而http2.0中的==多路复用优化了这一性能。多路复用允许同时通过单一的http/2 连接发起多重的请求-响应消息==。有了新的分帧机制后，http/2 不再依赖多个TCP连接去实现多流并行了。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级，最后再在另一端把它们重新组合起来。
	
	- http 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。http2连接可以承载数十或数百个流的复用，多路复用意味着来自很多流的数据包能够混合在一起通过同样连接传输。当到达终点时，再根据不同帧首部的流标识符重新连接将不同的数据流进行组装。

- **3.0 协议，**整合了tls1.3整合到TCP握手，封装到QUIC协议


## 2.2  url工作流程

1. 点击浏览器上的url，如果URL中有文字就必须编码，浏览器就开始url编码， 
2. 如果是浏览器，那么还会有一种新的Web安全协议HSTS，HSTS的作用是强制客户端使用HTTPS与服务器创建连接。比如你在地址栏输入http://xxx/，浏览器会自动将http转写成https，然后直接向 https://xxx/ 发送请求。
3. 检查有无http缓存，
4. 对域名进行过解析，浏览器/手机则是系统的缓存 查询缓存dns，没有就查询系统Hosts文件中有无配置，DNS缓存是否有该域名对应IP，再无就通过udp访问==本地服务提供商的本地dns服务器==（例如：114.114.114.144，8.8.8.8），再无就udp访问==根dns服务器==。
5. 通过cdn全局分发服务器访问对应cdn服务器，web浏览器与web服务器tcp三次握手建立连接。

6. 建立连接后，客户端发送请求给服务器，按照请求格式为资源定位符，
7. 通过后台服务器请求分发或者反向代理到对应服务器
8. 服务器处理请求，并作出响应，浏览器接收到响应，通过四次挥手断开tcp链接

扩展：根服务器全球13个，主根服务器在美国。根服务器存储了互联网配置和信息，具体操作时下发其他服务器。
## 2.3 常见的HTTP错误码

请求各种资源，网页

| 错误码  |              意义              |
| :-----: | :----------------------------: |
| **200** |            请求成功            |
| **302** |            请求重定向            |
| **304** |            使用缓存            |
| **400** |          请求语法有误          |
|   401   |             未授权             |
| **403** |       已收到，请求被拒绝       |
| **404** |         请求资源不存在         |
| **500** |           服务器错误           |
|   503   | 服务器不能处理当前客户端的请求 |



## 2.4 Post和Get和Put

### 基础：
Get: 请求参数以明文的方式在url显示，最长不超过2kb。 会被浏览器主动缓存。 非acsii码会被**转码**（比如中文）。用于获取资源较多。发送一个

Post: 请求参数在请求体中，理论上长度可以无限大。**不转码**，用于上传和修改操作较多。
有些框架有时候会发送两个tcp包，第一个发送header，第二个是data。不要混淆，一般都是尽可能一个包内发送完。


GET/POST都是TCP链接 
HTTP 协议里，所谓的“安全”是指请求方法不会对服务器上的资源进行修改，“破坏”服务器上的资源，所以get比post安全

put: 如果两个请求相同，后一个请求会把第一个请求覆盖掉 


除此之后还有其他delete，head等

### 进阶：
在HTTP协议中，请求方法（也称为HTTP谓词）用于指定对某个资源的操作。GET、POST、PUT等都是HTTP请求方法的一种。HTTP请求方法通常位于请求行的开头，紧跟着请求的URL和协议版本，各部分之间通过空格分隔。

以下是各请求方法在HTTP请求中的简要表示：

1. GET请求

```
GET /example HTTP/1.1
Host: www.example.com
```

2. POST请求

```
POST /example HTTP/1.1
Host: www.example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: [length of the request body]

key1=value1&key2=value2

```

3. PUT请求

```
PUT /example HTTP/1.1
Host: www.example.com
Content-Type: application/json
Content-Length: [length of the request body]

{
  "key1": "value1",
  "key2": "value2"
}
```

这里的三个请求示例分别表示了GET、POST、PUT请求。每个HTTP请求的第一行为请求行，它包含请求方法（如GET、POST或PUT）、请求的资源（如/example路径）以及协议版本（如HTTP/1.1）。后面的部分包含请求头和请求体（仅在需要发送数据时使用，如POST和PUT请求）。

注意：在实际使用中，HTTP请求可能包含更多的请求头，以指定其他请求信息，如预期的响应类型、来源页面等


### Post和Get
get请求参数会暴露在url中进行传输，而post请求参数是放在Request Body中，相对来说比get安全。get的参数会被保存在==web服务器和浏览器的记录中==。

● get请求只支持url编码，而post支持多种编码方式。

● 针对数据的操作不同
get主要是用来读取数据，而post主要对数据进行增删改。

● get比较常见的是通过url发起请求，而post的较为常见的是通过表单发起请求。

● 为什么Get比Post快？
	用屁股想都知道，get一般用来获取数据，post还需要进行修改，一般也用来传输数据，你说能不慢吗？

幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。

所有的安全方法也都是幂等的。

- 在==正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是==。

- GET /pageX HTTP/1.1 ==是幂等的，连续调用多次，客户端接收到的结果都是一样的==。

- POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录。

- DELETE /idX/delete HTTP/1.1==是幂等的，即使不同的请求接收到的状态码不一样==。 


### 1.HTTP Request Header请求头信息对照表:

| *Header*                | 解释                                                       | 示例                                                  |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------- |
| ***Accept***            | 指定客户端能够接收的内容类型*                               | *Accept: text/plain, text/html*                         |
| ***Accept-Charset***    | ***浏览器可以接受的字符编码集。***                           | *Accept-Charset: iso-8859-5*                            |
| ***Accept-Encoding*`**  | **指定浏览器可以支持的web服务器返回内容压缩编码类型。**      | *Accept-Encoding: compress, gzip*                       |
| ***Accept-Language***   | *浏览器可接受的语言*                                         | *Accept-Language: en,zh*                                |
| ***Accept-Ranges***     | *可以请求网页实体的一个或者多个子范围字段*                   | *Accept-Ranges: bytes*                                  |
| ***Authorization***     | *HTTP授权的授权证书*                                         | *Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==*     |
| ***Cache-Control***     | *指定请求和响应遵循的缓存机制*       | *Cache-Control: no-cache*          |
| **Connection**          | ***表示是否需要持久连接。（HTTP 1.1默认进行持久连接）***     | *Connection: close*         |
| **Cookie**              | ***HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。*** | Cookie: $Version=1; Skin=new;                           |
| **Content-Length**      | 请求的内容长度                                               | Content-Length: 348                                     |
| **Content-Type****      | **请求的与实体对应的MIME信息**                               | **Content-Type: application/x-www-form-urlencoded**     |
| **Date**                | 请求发送的日期和时间                                         | Date: Tue, 15 Nov 2010 08:12:31 GMT                     |
| **Expect**              | 请求的特定的服务器行为                                       | Expect: 100-continue                                    |
| **From**                | 发出请求的用户的Email                                        | From: user@email.com                                    |
| **Host**                | **指定请求的服务器的域名和端口号**                           | Host: www.zcmhi.com                                     |
| **If-Match**            | 只有请求内容与实体相匹配才有效                               | If-Match: "737060cd8c284d8af7ad3082f209582d"            |
| **If-Modified-Since**   | 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 | If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT        |
| **If-None-Match**       | 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 | If-None-Match: "737060cd8c284d8af7ad3082f209582d"       |
| **If-Range**            |和分段下载， 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag | If-Range: "737060cd8c284d8af7ad3082f209582d"            |
| **If-Unmodified-Since** | 只在实体在指定时间之后未被修改才请求成功                     | If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT      |
| **Max-Forwards**        | 限制信息通过代理和网关传送的时间                             | Max-Forwards: 10                                        |
| **Pragma**              | 用来包含实现特定的指令                                       | Pragma: no-cache                                        |
| **Proxy-Authorization** | 连接到代理的授权证书                                         | Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== |
| **Range**               | 只请求实体的一部分，指定范围,可以实现分段下载                            | Range: bytes=500-999                                    |
| **Referer**             | 先前网页的地址，当前请求网页紧随其后,即来路                  | Referer: http://blog.csdn.net/coder_pig                 |
| **TE**                  | 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息     | TE: trailers,deflate;q=0.5                              |
| **Upgrade**             | 向服务器指定某种传输协议以便服务器进行转换（如果支持）       | Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11          |
| **User-Agent**          | User-Agent的内容包含发出请求的用户信息                       | User-Agent: Mozilla/5.0 (Linux; X11)                    |
| **Via**                 | 通知中间网关或代理服务器地址，通信协议                       | Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)             |
| **Warning**             | 关于消息实体的警告信息                                       | Warn: 199 Miscellaneous warning                         |

*2.HTTP响应之响应头:*

*如下图：PS:第一行依次是:协议版本号 状态码 302表示这里没有，但是另外一个地方有，通过Location页面重定向了*

*![img](https://images2015.cnblogs.com/blog/877390/201605/877390-20160509165733655-1149649973.png)*

 

*HTTP Responses Header 响应头信息对照表：*

| *Header*                 | *解释*                                                      | *示例*                                         |
| ------------------------ | ----------------------------------------------------------- | ---------------------------------------------- |
| ***Accept-Ranges***      | *表明服务器是否支持指定范围请求及哪种类型的分段请求*        | *Accept-Ranges: bytes*                         |
| ***Age***                | *从原始服务器到代理缓存形成的估算时间（以秒计，非负）*      | *Age: 12*                                      |
| ***Allow***              | *对某网络资源的有效的请求行为，不允许则返回405*             | *Allow: GET, HEAD*                             |
| ***Cache-Control***      | *告诉所有的缓存机制是否可以缓存及哪种类型*                  | *Cache-Control: no-cache*                      |
| ***Content-Encoding***   | ***web服务器支持的返回内容压缩编码类型***                   | *Content-Encoding: gzip*                       |
| ***Content-Language***   | *响应体的语言*                                              | *Content-Language: en,zh*                      |
| ***Content-Length***     | *响应体的长度*                                              | *Content-Length: 348*                          |
| ***Content-Location***   | *请求资源可替代的备用的另一地址*                            | *Content-Location: /index.htm*                 |
| ***Content-MD5***        | *返回资源的MD5校验值*                                       | Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==       | 
| ***Content-Range***      | *在整个返回体中本部分的字节位置*                            | *Content-Range: bytes 21010-47021/47022*       |
| ***Content-Type***       | ***返回内容的MIME类型***                                    | ***Content-Type: text/html; charset=utf-8***   |
| ***Date***               | *原始服务器消息发出的时间*                                  | *Date: Tue, 15 Nov 2010 08:12:31 GMT*          |
| ***ETag***               | *请求变量的实体标签的当前值*                                | *ETag: "737060cd8c284d8af7ad3082f209582d"*     |
| ***Expires***            | *响应过期的日期和时间*                                      | *Expires: Thu, 01 Dec 2010 16:00:00 GMT*       |
| ***Last-Modified***      | *请求资源的最后修改时间*                                    | *Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT* |
| ***Location***           | *用来重定向接收方到非请求URL的位置来完成请求或标识新的资源* | *Location: http://blog.csdn.net/coder_pig*     |
| ***Pragma***             | *包括实现特定的指令，它可应用到响应链上的任何接收方*        | *Pragma: no-cache*                             |
| ***Proxy-Authenticate*** | *它指出认证方案和可应用到代理的该URL上的参数*               | *Proxy-Authenticate: Basic*                    |

# HTTPS

![[20190427173316209.png]]
![[v2-0ae984a8365fe961a03d0b8ad3c18759_720w.webp]]

HTTPS 协议是由 HTTP 加上 TLS/SSL 协议构建的可进行加密传输、身份认证的网络协议。TLS 的前身是 SSL，TLS1.0 就是 SSL3.1，TLS1.1 是 SSL3.2，TLS1.2 则是 SSL3.3。HTTPS 标准端口是 443。TLS/SSL  中使用了非对称加密，对称加密以及 Hash 算法。SSL/TSL握手完成之后就使用**对称加密通信了**。

## 4.1 证书

### 证书产生过程

1. 向 CA 机构提交申请，提交信息包括：
   - 公司信息
   - 域名
   - 加密算法（例如：RSA）
   - Hash 签名算法（例如：sha256）
   - 加密位数
2. CA 机构收到证书申请，发送证书和私钥给申请者，证书包含这些信息：
   - 证书内容（域名、公钥、有效期等等）
   - 证书签名（Hash 签名算法对内容摘要，CA 机构再用自己的私钥对摘要进行加密，得到证书签名）

## 认证过程

### https 连接过程**

那么 HTTPS 具体是怎么做的呢？通信双方在什么时候协商`会话密钥`和`鉴别密钥`、什么时候验证`证书`合法性的呢？答案是 SSL/TLS 协议四次握手的时候。
![[v2-26fb594abe78e4002f9cf0686059079c_720w.webp]]
![[v2-ec29ae5a6a025aa92af36089b2c1eec9_720w.webp]]

![[20190216154130687.png]]

1. 客户端发送 Client Hello 给服务端，包含以下信息：
   - 支持的 TLS 版本
   - 支持的加密方式
   - 随机数 random_C
   - 域名
2. 服务端收到请求后，发送 server Hello，包含以下信息：
   - 确定 TLS 版本
   - 随机数 random_S
   - 确定加密方式
   - 证书
     - 包含证书内容(域名、公钥、有效期等等)
     - 包含证书签名（用于验证是否内容是否没被修改）
3. 客户端收到请求后，将会做一下事情：
   - 验证证书---公钥==解密签名后的和内容摘要对比、和验证有效期==
     - 操作系统和浏览器中存有 CA 机构的公钥。 客户端使用 CA 机构的公钥对签名进行解密，解密成功说明证书由 CA 机构颁发
     - 签名成功解密后得到证书摘要。客户端使用 Hash 签名算法（比如sha256，hash）对证书内容进行摘要，然后和签名解密后的摘要比较，相等说明证书没有被修改过。证书内容（公钥、域名、有效期）可信
     - 客户端验证证书内容的域名是否和当前网址是一致的，证书是否过期。
   - 生成随机数
     - 验证通过后，客户端生成随机数 Pre-master，==然后用证书中的公钥进行加密==，发送给服务端Finished报文
1. 服务端
   - 服务端使用 CA 机构给的==密钥对加密的随机数进行解密==，获取随机数 Pre-master
2. 客户端/服务端
   - 服务器务器同样发送Finished报文，用来供客户端校验。
   - 服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求。
   - 服务端和客户端分别用根据 random_C，random_S 和 Pre-master 生成密钥，用于对称加密传输数据
   
**SSL/TLS 握手**

根据前面所述，进行一下小结：

- HTTPS 通过混合加密算法解决 HTTP 传输数据容易被窃听的问题兼顾性能，此过程需要协商`会话密钥`。
- HTTPS 通过  证书内容摘要算法  解决 HTTP 传输数据容易被篡改的问题，此过程需要协商`鉴别密钥`。也就是验证证书内容的摘要。根证书公钥解密签名--->对比内容
- HTTPS 通过数字证书解决 HTTP 协议中秘钥容易被伪造的问题，此过程需要客户端验证服务器的`证书`。
-  random_C，random_S 和 Pre-master 生成密钥，用于对称加密传输数据。而且也能避免黑客重复发送数据报扰乱。


关键点就在于
- 三次随机码
- 证书已经第三方ca提供的公钥



### 问题
- 为什么要用对称加密+非对称加密？
- 为什么不能只用非对称加密？
- 为什么需要数字证书？
- 为什么需要数字签名？

http和https
![[20190427173552711.png]]
## TLS1.2、TLS1.3


# 3.TCP和UDP

传输层协议，Tcp可靠连接 udp不可靠，udp尽最大努力传输

详细文章：[[https://zhuanlan.zhihu.com/p/374998210]]
![[4264767-21a37be67ea1220f.webp]]



![[v2-dbcb3f26aef5d06441d1511d0054def4_720w.webp]]
## TCP
头格式
![[v2-5b92d6e33e2962779a5e25b55a337691_720w.webp]]

> 为什么需要 TCP 协议？ TCP 工作在哪一层？  

`IP` 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。
如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 `TCP` 协议来负责。

因为 TCP 是一个工作在**传输层**的**可靠**数据传输的服务，它能确保接收端接收的网络包是**无损坏、无间隔、非冗余和按序的。**

> 什么是 TCP ？  

TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议。

![](https://pic2.zhimg.com/80/v2-a6eb6e5184038a04a9f312f016417b91_720w.webp)

- **面向连接**：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；  
    
- **可靠的**：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；  
    
- **字节流**：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。
### 3.1 三次握手和四次挥手

syn同步码，ack确认码 
ACK 确认标示位，SYN 同步（握手）标示位，FIN 结束表示位 


在sokcet中：
`accept()`操作在TCP协议的“三次握手”过序列中的最后一步：
	Client发送ACK包回复，ack=y+1, seq=x+1。

`accept()`在第三步中被调用。当服务器收到来自客户端的清晰为SYN的数据包后，会发送一个SYN/ACK数据包给客户端。此后，服务器立即调用`accept()`函数，开始等待来自客户端的ACK响应。一旦服务器收到这个ACK响应，`accept()`函数就会返回，这样三次握手过程就完成了，TCP连接即被建立。

注意：`accept()`操作并不直接在协议中指定，但它实现了三次握手协议的最后一步功能。

### 三次握手

![在这里插入图片描述](20191025171032191.png) 

![[v2-861fa058f2da35f8efa70b29bf7c45fd_b.webp]]
1. 第一次握手：客户端向服务端发送**syn包**请求连接并携带sequeuece序号，同时进入SYN_SENT等待同步 状态，**等待服务器响应**，这个syn指**同步序列编号**。
	- 问题一：syn确定通道唯一性，好比socket通信的端口，该握手是针对某个通道进行的
	- 问题二：seq是确定该通道进行的步骤，以排除累赘信息，比如同一通道在建立通信前多次发出第一次握手，那么我们就需要知道哪个是第一次握手来的信息，哪个是第二次握手的信息。

2. 第二个握手：服务端接收到syn包后，自己也向客户端发送一个syn+ ack（ack = seq+1）+ seq(服务端生成的)包，表示已经监听到客户端的请求并给你反馈。同时进入**SYN_RECV同步接收状态**。
-  ack是给客户端做第三次握手的确认码

3. 第三次握手：客户端收到服务端的确认信息后向服务器发送**ACK（服务端生成的序列号seq +1）确认包**，发送完毕后进入ESTABLISHED状态，三次握手完成。
	1. 此处的客户端发送的是第一次握手的seq+1，证明是客户端发送的第二次握手，说明已经进行到了第三步。
	2. 并且发送了ack = 服务端发送的seq + 1 说明是服务器发起的第二次握手已确认收到。

关键点其实是只要理解seq的作用就其他都理解了。seq是区分当前进行到哪一个步骤的，而且。发送ack（seq +1）就是确认某个seq已完成，也就是某个步骤已经完成。

这里有个小细节，==第三次握手是可以携带数据的，这是面试常问的点。==

> **那么为什么要三次握手呢？两次不行吗？**

- 为了防止服务器端开启一些无用的连接增加服务器开销
- 防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

由于网络传输是有延时的(要通过网络光纤和各种中间代理服务器)，在传输的过程中，比如客户端发起了 SYN=1 的第一次握手。

如果服务器端就直接创建了这个连接并返回包含 SYN、ACK 和 Seq 等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直没有接收到服务器返回的数据包。

如果没有第三次握手告诉服务器端客户端收的到服务器端传输的数据的话，服务器端是不知道客户端有没有接收到服务器端返回的信息的。服务端就认为这个连接是可用的，端口就一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。

这样一来，就会有很多无效的连接端口白白地开着，导致资源的浪费。
#### **SYN攻击：**

在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：

> #netstat -nap | grep SYN_RECV


#### 四次挥手
![[v2-68f0f12b1cfbbb6bd1a28f0c6efe3559_720w.png]]
![[v2-c6d70b9f08ae74a2cde80cb6f3eb849b_r.png]]
![在这里插入图片描述](20191025171735990.png) 



1. 客户端向服务端发送一个**FIN包**（客户端服务端都可以发送，这里以客户端为例），表示我要和你断开连接，同时进入FIN-WAIT-1（**终止等待1阶段**）

2. 服务端收到你的FIN包后给你发送确认报文，同时自己进入**CLOSE-WAIT状态。**

3. 客户端收到服务端的确认报文后，**进入FIN-WAIT-2状态，并等待服务器发送释放连接报文。**

4. **服务端在自己的事情做完之后**，向客户端发送FIN报文，同时进入Last-ACK（最后确认状态）

5. 客户端接收到服务端的信息后发送ACK报文携带ack ，同时自己进入Time-WAIT状态，**等待一段时间后进入CLOSE状态。**
6.服务端接收到客户端的确认信息后立即进入CLOSE状态。

对比：
握手 就是发送syn标志位，挥手就是发送fin标志位。seq都是用来表示当前步骤是发送方的第几次发，ack表示是第几次发的确认收到。


### 3.2 TCP拥塞控制

**控制发送速率，防止过多的数据注入网络，影响所有的网络资源所有主机。**
概念：
RTT 一次往返通信的时间
cwnd 拥塞窗口，说白了就是一次数据的大小
ssthresh 慢开始的最大阈值
发送速率 = CWND / RTT
那么拥塞控制就是控制着速率，但是RTT一般不改变，那么主要就是控制CWND的大小了。

**TCP的四种拥塞控制算法**  
- 1.慢开始  
- 2.拥塞避免  
- 3.快重传  
- 4.快恢复
![[20190731184935595.png]]
- 超时/丢包  ---> 慢开始，指数增长，但是会有一个阈值来避免过快，也就是sshresh
- 拥塞避免 ---> cwnd呈线性增长。==如果发生超时（在），就会又进入慢开始。==超时时间都是由RTT再去动态变化计算的。超时一般代表网络情况非常差。
- 快重传 ----> 大文件在传输层会被拆分成多个有序报文段，==可能某个报文段丢失了，接收方会一直发送对应的确认报文，如果收到3个连续的有序重复报文段时候就要马上重新发送对应确认报文，也就是快重传==。
![[截图20230827213342.png]]
- 快恢复  
当发送端==收到连续三个重复==的确认时，不执行慢开始算法，而是执行==快恢复算法==（效率就高很多了）收到连续确认说明是网络比较差。
- 慢开始门限ssthresh=当前拥塞窗口cwnd/2；  
- 乘法减小拥塞窗口。  
	- 新拥塞窗口cwnd=慢开始门限ssthresh；  
	- 执行[拥塞避免]算法，使拥塞窗口缓慢地线性增大。

### TCP数据分段
TCP分段机制是当应用层有大数据传输时，TCP传输层会对数据报进行分段传输。并且会对分段的数据报进行编号排序，服务器端收到分段数据后会重新按照顺序编排在传输给应用层。
重传机制和不同的网络路径会导致乱序。

### 流量控制

接收方是有接受缓存的，控制住发送方的速率以保证接收方能最大能力接收，避免拥塞和数据丢失。
通过滑动窗口控制cwnd 发送窗口，rewnd接受窗口，也就是接收方还有剩下多大的接受缓存空间，他是动态变化的，也就是**滑动窗口**。
我们TCP数据报头的窗口大小有标明了。

### 两者对比
==拥塞控制是整体网络==出现问题拥堵所以采取不同的速率控制来避免拥堵；==流量控制避免是发送方与接收方本身==发送能力和接收能力波动导致数据丢失。

## 3.3 常见问题：

【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？

答：`因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。`

【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？*

`*答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。  所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。  在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。`

`【问题3】为什么不能用两次握手进行连接？*

`答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。`

​       `现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。`

【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还==设有一个保活计时器==，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，==时间通常是设置为2小时，**若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文**段==，以后每隔75秒钟发送一次。若一连==发送10个探测报文仍然没反应==，服务器就认为客户端出了故障，接着就关闭连接。

## 3.3 UDP
面向报文的不可靠链接，为什么说是面向报文？因为就是只考虑发送报文就够了.
实际使用的时候一般还是设计一层应用层的可靠机制再进行传输。

	
# 5. 流媒体传输协议

查看另一文件：[[音视频开发--基于Android平台]]