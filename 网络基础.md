# 1.网络基础

## 1.网络分层

除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议，它们之间的对应关系如下图所示：



osi七层协议 [ 应用，表，会]，传，网，数，物，
巧记:  应用表示会话, 传输网络和链路，还有 物理


下面是协议层从底层至顶层的一个模型图：

![img](https://images2015.cnblogs.com/blog/983980/201611/983980-20161121173924409-1128983178.png)

 

![img](1538030296-7490-20150904094019903-1923900106.jpg)



## 2. **什么是URL？**

**统一资源定位符**（Uniform Resource Locator），是因特网上标准的资源地址。URL格式主要分为三个部分：

1、**协议**，如Http、Https(HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 [TCP](https://baike.baidu.com/item/TCP/33012) 之间） )。

2、**存有该资源的IP地址**，有时候也包括端口号。如：192.168.1.112（现在基本使用域名代替，如：www.baidu.com）

3、**主机资源的具体地址**。如文件和目录名。如：index.jsp或aaa.doc

1和2之间用“://”隔开，2和3用“/”分开。1和2是不可缺少的，3是可以缺少的。
## 3.  TCP/IP/UDP

.说一说 HTTPS、UDP、Socket 之间的区别？

参考答案：

TCP(Transmission Control Protocol,传输控制协议)与UDP(User Data Protocol,用户数据协议)是互联网传输数据较为常用的协议，我们熟知的HTTP就是基于TCP的.

而HTTPS就是HTTP 加上SSL的加密方式：

UDP是非面向连接的协议，发送数据时不管对方状态直接发送，无需建立连接，如同微信发送一个消息或者语音信息，对面在不在线无所谓.

Socket不属于协议范畴，别名套接字通过调用Socket，才能使用TCP/IP协议，Socket连接是长连接，理论上客户端和服务器端一旦建立连接将不会主动断开此连接。Socket连接属于请求-响应形式，服务端可主动将消息推送给客户端。

Socket是操作系统提供的一套对TCP的抽象操作的api，隐藏了TCP链接的细节。

socket常见操作：
new Socket

# 2.HTTP

**超文本协议 ，是互联网上应用最为广泛的一种网络协议 ，TCP/IP一个应用层的协议。**

**Https(HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 [TCP](https://baike.baidu.com/item/TCP/33012) 之间） , 采用非对称密钥)。**



1、支持客户端/服务器模式：就是客户端请求，服务器做出响应。

2、简单快速：客户端向服务器请求服务时，是需要传入请求方法和路径。请求方法常用的有GET、POST。每种方法都规定了客户端与服务器联系的类型不同。

3、**灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。**

4、无连接：无连接的含义就是限制每次连接只处理一个请求。服务器处理完客户端的请求，并收到客户端的应答之后，即立即断开连接。

5、无状态：HTTP协议是无状态的协议。无状态就是指协议对于事务的处理是没有记忆能力的。缺少状态就意味着如果后续处理需要前面的信息，则必须重新传送，这样会导致每次连接传送的数据量大。另一方面，在服务器不需要先前信息时，它的应答就会较快。

原文链接：https://blog.csdn.net/u014544193/article/details/49849843

## 2.1 http1.0和http1.1

- **1.0协议，客户端与web服务器建立连接后，只能获得一个web资源！（资源静态，动态资源 ---servlet等等）**
- **1.1协议，允许客户端与web服务器建立连接后，在一个连接上获取多个web资源！**

## 2.2  url工作流程

1. 点击浏览器上的url，如果URL中有文字就必须编码，浏览器就开始url编码， 
2. 如果是浏览器，那么还会有一种新的Web安全协议HSTS，HSTS的作用是强制客户端使用HTTPS与服务器创建连接。比如你在地址栏输入http://xxx/，浏览器会自动将http转写成https，然后直接向 https://xxx/ 发送请求。
3. 检查有无http缓存，
4. 对域名进行过解析，浏览器查询缓存dns，没有就查询系统Hosts文件中有无配置，DNS缓存是否有该域名对应IP，再无就通过udp访问本地服务提供商的本地dns服务器（例如：114.114.114.144，8.8.8.8），再无就udp访问根dns服务器。
5. 通过cdn全局分发服务器访问对应cdn服务器，web浏览器与web服务器tcp三次握手建立连接。

6. 建立连接后，客户端发送请求给服务器，按照请求格式为资源定位符，
7. 通过后台服务器请求分发或者反向代理到对应服务器
8. 服务器处理请求，并作出响应，浏览器接收到响应，通过四次挥手断开tcp链接

扩展：根服务器全球13个，主根服务器在美国。根服务器存储了互联网配置和信息，具体操作时下发其他服务器。
## 2.3 错误码

请求各种资源，网页

| 错误码  |              意义              |
| :-----: | :----------------------------: |
| **200** |            请求成功            |
| **400** |          请求语法有误          |
|   401   |             未授权             |
| **403** |       已收到，请求被拒绝       |
| **404** |         请求资源不存在         |
| **500** |           服务器错误           |
|   503   | 服务器不能处理当前客户端的请求 |



## 2.4 Post和Get和Put

### 基础：
Get: 请求参数以明文的方式在url显示，最长不超过2kb。 会被浏览器主动缓存。 非acsii码会被**转码**（比如中文）。用于获取资源较多。发送一个

Post: 请求参数在请求体中，理论上长度可以无限大。**不转码**，用于上传和修改操作较多。发送两个tcp包，第一个发送header，第二个是data


GET/POST都是TCP链接 


put: 如果两个请求相同，后一个请求会把第一个请求覆盖掉 


除此之后还有其他delete，head等

### 进阶：


## 2.5 请求头和响应头

1.HTTP Request Header请求头信息对照表:

| *Header*                | *解释*                                                       | *示例*                                                  |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------- |
| ***Accept***            | *指定客户端能够接收的内容类型*                               | *Accept: text/plain, text/html*                         |
| ***Accept-Charset***    | ***浏览器可以接受的字符编码集。***                           | *Accept-Charset: iso-8859-5*                            |
| ***Accept-Encoding*`**  | **指定浏览器可以支持的web服务器返回内容压缩编码类型。**      | *Accept-Encoding: compress, gzip*                       |
| ***Accept-Language***   | *浏览器可接受的语言*                                         | *Accept-Language: en,zh*                                |
| ***Accept-Ranges***     | *可以请求网页实体的一个或者多个子范围字段*                   | *Accept-Ranges: bytes*                                  |
| ***Authorization***     | *HTTP授权的授权证书*                                         | *Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==*     |
| ***Cache-Control***     | *指定请求和响应遵循的缓存机制*                               | *Cache-Control: no-cache*                               |
| **Connection**          | ***表示是否需要持久连接。（HTTP 1.1默认进行持久连接）***     | *Connection: close*                                     |
| **Cookie**              | ***HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。*** | Cookie: $Version=1; Skin=new;                           |
| **Content-Length**      | 请求的内容长度                                               | Content-Length: 348                                     |
| **Content-Type****      | **请求的与实体对应的MIME信息**                               | **Content-Type: application/x-www-form-urlencoded**     |
| **Date**                | 请求发送的日期和时间                                         | Date: Tue, 15 Nov 2010 08:12:31 GMT                     |
| **Expect**              | 请求的特定的服务器行为                                       | Expect: 100-continue                                    |
| **From**                | 发出请求的用户的Email                                        | From: user@email.com                                    |
| **Host**                | **指定请求的服务器的域名和端口号**                           | Host: www.zcmhi.com                                     |
| **If-Match**            | 只有请求内容与实体相匹配才有效                               | If-Match: "737060cd8c284d8af7ad3082f209582d"            |
| **If-Modified-Since**   | 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 | If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT        |
| **If-None-Match**       | 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 | If-None-Match: "737060cd8c284d8af7ad3082f209582d"       |
| **If-Range**            | 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag | If-Range: "737060cd8c284d8af7ad3082f209582d"            |
| **If-Unmodified-Since** | 只在实体在指定时间之后未被修改才请求成功                     | If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT      |
| **Max-Forwards**        | 限制信息通过代理和网关传送的时间                             | Max-Forwards: 10                                        |
| **Pragma**              | 用来包含实现特定的指令                                       | Pragma: no-cache                                        |
| **Proxy-Authorization** | 连接到代理的授权证书                                         | Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== |
| **Range**               | 只请求实体的一部分，指定范围                                 | Range: bytes=500-999                                    |
| **Referer**             | 先前网页的地址，当前请求网页紧随其后,即来路                  | Referer: http://blog.csdn.net/coder_pig                 |
| **TE**                  | 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息     | TE: trailers,deflate;q=0.5                              |
| **Upgrade**             | 向服务器指定某种传输协议以便服务器进行转换（如果支持）       | Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11          |
| **User-Agent**          | User-Agent的内容包含发出请求的用户信息                       | User-Agent: Mozilla/5.0 (Linux; X11)                    |
| **Via**                 | 通知中间网关或代理服务器地址，通信协议                       | Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)             |
| **Warning**             | 关于消息实体的警告信息                                       | Warn: 199 Miscellaneous warning                         |

*2.HTTP响应之响应头:*

*如下图：PS:第一行依次是:协议版本号 状态码 302表示这里没有，但是另外一个地方有，通过Location页面重定向了*

*![img](https://images2015.cnblogs.com/blog/877390/201605/877390-20160509165733655-1149649973.png)*

 

*HTTP Responses Header 响应头信息对照表：*

| *Header*                 | *解释*                                                      | *示例*                                         |
| ------------------------ | ----------------------------------------------------------- | ---------------------------------------------- |
| ***Accept-Ranges***      | *表明服务器是否支持指定范围请求及哪种类型的分段请求*        | *Accept-Ranges: bytes*                         |
| ***Age***                | *从原始服务器到代理缓存形成的估算时间（以秒计，非负）*      | *Age: 12*                                      |
| ***Allow***              | *对某网络资源的有效的请求行为，不允许则返回405*             | *Allow: GET, HEAD*                             |
| ***Cache-Control***      | *告诉所有的缓存机制是否可以缓存及哪种类型*                  | *Cache-Control: no-cache*                      |
| ***Content-Encoding***   | ***web服务器支持的返回内容压缩编码类型***                   | *Content-Encoding: gzip*                       |
| ***Content-Language***   | *响应体的语言*                                              | *Content-Language: en,zh*                      |
| ***Content-Length***     | *响应体的长度*                                              | *Content-Length: 348*                          |
| ***Content-Location***   | *请求资源可替代的备用的另一地址*                            | *Content-Location: /index.htm*                 |
| ***Content-MD5***        | *返回资源的MD5校验值*                                       | *Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==*        |
| ***Content-Range***      | *在整个返回体中本部分的字节位置*                            | *Content-Range: bytes 21010-47021/47022*       |
| ***Content-Type***       | ***返回内容的MIME类型***                                    | ***Content-Type: text/html; charset=utf-8***   |
| ***Date***               | *原始服务器消息发出的时间*                                  | *Date: Tue, 15 Nov 2010 08:12:31 GMT*          |
| ***ETag***               | *请求变量的实体标签的当前值*                                | *ETag: "737060cd8c284d8af7ad3082f209582d"*     |
| ***Expires***            | *响应过期的日期和时间*                                      | *Expires: Thu, 01 Dec 2010 16:00:00 GMT*       |
| ***Last-Modified***      | *请求资源的最后修改时间*                                    | *Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT* |
| ***Location***           | *用来重定向接收方到非请求URL的位置来完成请求或标识新的资源* | *Location: http://blog.csdn.net/coder_pig*     |
| ***Pragma***             | *包括实现特定的指令，它可应用到响应链上的任何接收方*        | *Pragma: no-cache*                             |
| ***Proxy-Authenticate*** | *它指出认证方案和可应用到代理的该URL上的参数*               | *Proxy-Authenticate: Basic*                    |



# 3.TCP/IP和UDP

传输层协议，Tcp可靠连接 udp不可靠，udp尽最大努力传输

## 3.1 三次握手和四次挥手

syn同步码，ack确认码



三次握手：

![在这里插入图片描述](20191025171032191.png) 

1.第一次握手：客户端向服务端发送**syn包**请求连接，同时进入SYN_SENT状态，**等待服务器响应**，这个syn指同步序列编号。
2.第二个握手：服务端接收到syn包后，自己也向客户端发送一个syn+ack包，表示监听到你的请求并给你反馈。同时进入SYN_RECV状态。
3.第三次握手：客户端收到服务端的确认信息后向服务器发送**ACK确认包**，发送完毕后进入ESTABLISHED状态，三次握手完成。



![在这里插入图片描述](20191025171735990.png) 

1.客户端向服务端发送一个**FIN包**，表示我要和你断开连接，同时进入FIN-WAIT-1（**终止等待1阶段**）

2.服务端收到你的FIN包后给你发送确认报文，同时自己进入**CLOSE-WAIT状态。**

3.客户端收到服务端的确认报文后，**进入FIN-WAIT-2状态，并等待服务器发送释放连接报文。**

4.**服务端在自己的事情做完之后**，**向客户端发送FIN报文，同时进入Last-ACK（最后确认状态）**

5.客户端接收到服务端的信息后发送ACK报文，同时自己进入Time-WAIT状态，等待一段时间后进入CLOSE状态。
6.服务端接收到客户端的确认信息后立即进入CLOSE状态。




## 3.2 常见问题：

【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？

答：`因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。`

【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？*

`*答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。  所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。  在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。`

`【问题3】为什么不能用两次握手进行连接？*

`答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。`

​       `现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。`

【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，**若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文**段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

## 3.3 UDP

# 4.HTTPS

HTTPS 协议是由 HTTP 加上 TLS/SSL 协议构建的可进行加密传输、身份认证的网络协议。TLS 的前身是 SSL，TLS1.0 就是 SSL3.1，TLS1.1 是 SSL3.2，TLS1.2 则是 SSL3.3。HTTPS 标准端口是 443。TLS/SSL  中使用了非对称加密，对称加密以及 Hash 算法。

## 4.1 证书

### 证书产生过程

1. 向 CA 机构提交申请，提交信息包括：
   - 公司信息
   - 域名
   - 加密算法（例如：RSA）
   - Hash 签名算法（例如：sha256）
   - 加密位数
2. CA 机构收到证书申请，发送证书和私钥给申请者，证书包含这些信息：
   - 证书内容（域名、公钥、有效期等等）
   - 证书签名（Hash 签名算法对内容摘要，CA 机构再用自己的私钥对摘要进行加密，得到证书签名）

## 认证过程

### https 连接过程	

1. 客户端发送 Client Hello 给服务端，包含以下信息：
   - 支持的 TLS 版本
   - 支持的加密方式
   - 随机数 random_C
   - 域名
2. 服务端收到请求后，发送 server Hello，包含以下信息：
   - 确定 TLS 版本
   - 随机数 random_S
   - 确定加密方式
   - 证书
     - 内容(域名、公钥、有效期等等)
     - 签名
3. 客户端收到请求后，将会做一下事情：
   - 验证证书
     - 操作系统和浏览器中存有 CA 机构的公钥。 客户端使用 CA 机构的公钥对签名进行解密，解密成功说明证书由 CA 机构颁发。
     - 签名成功解密后得到证书摘要。客户端使用 Hash 签名算法对证书内容进行摘要，然后和签名解密后的摘要比较，相等说明证书没有被修改过。证书内容（公钥、域名、有效期）可信。
     - 客户端验证证书内容的域名是否和当前网址是一致的，证书是否过期。
   - 生成随机数
     - 验证通过后，客户端生成随机数 Pre-master，然后用证书中的公钥进行加密，发送给服务端
4. 服务端
   - 服务端使用 CA 机构给的密钥对加密的随机数进行解密，获取随机数 Pre-master
5. 客户端/服务端
   - 服务端和客户端分别用根据 random_C，random_S 和 Pre-master 生成密钥，用于加密传输数据。

# 5. 流媒体传输协议

查看另一文件：[[音视频开发--基于Android平台]]