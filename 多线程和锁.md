
# 线程

是操作系统中调度的最小单位，

1. **新建(NEW)**：新创建了一个线程对象。

2. **可运行(或者叫等待运行 RUNNABLE)**：线程对象创建后，其他线程(比如main线程）调**用了该对象的start()方法**。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。

3. **运行(RUNNING)**：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。



**阻塞(BLOCKED)**：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： 

> (一). **等待阻塞**：运行(running)的线程执行**o.wait()方法**，JVM会把该线程放入等待队列(waitting queue)中。 
> (二). **同步阻塞**：运行(running)的线程在获取对象的同步锁时，若该同步锁**被别的线程占用**，则JVM会把该线程放入锁池(lock pool)中。 
> (三). **其他阻塞**：运行(running)的线程执行**Thread.sleep(long ms)或t.join(**)方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

5. **死亡(DEAD)**：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。

 

## 等待唤醒机制

调用wait()方法后，线程会释放掉他所占用的锁，从而使线程所在对象中的其他synchronized数据可以被其他线程使用。 

对象被调用wait之后的线程处于一个wait set中。

noftify和notifyall。

以上过程都必须在锁中进行

# 锁

java中的锁标志存在于对象头中



## 锁的四种状态

无锁：没有竞争或者是通过其他方式来限制（例如volatile关键字，CAS）

偏向锁：只有一个线程占用了锁的时候，线程便处于该状态

轻量级锁：多个线程竞争时升级为该锁

重量级锁：等待的线程超过一个，升级为重量级锁

## noftify和notifyall

两个概念：

- 等待池：假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池，等待池中的线程不会去竞争该对象的锁。
- 锁池：只有获取了对象的锁，线程才能执行对象的 synchronized 代码，对象的锁每次只有一个线程可以获得，其他线程只能在锁池中等待

notify：随机唤醒等待池中的一个线程

notifyAll:唤醒等待池中的所有线程，进入锁池



都是object对象的默认方法。

```java
Object a;

//thread 1:

//悲观锁
//非公平锁
//可重入锁
synchronized(a){

    try{
        a.wait();//进入阻塞状态
        sout("thread 1");
    }catch(InterruptedException e){
        
    }
}

//thread 2
synchronized(a){
    try{
        Thread.sleep(3000);
       
    }catch(InterruptedExcetion e){
        
    }
    a.notify();//随机唤醒a的等待池中的一个线程
}
```

## 

## 乐观锁和悲观锁

这是锁的主要分类



**乐观锁（无锁**）： 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据， **如java.util.concurrent.atomic下的原子类**

**悲观锁：synchronized**，总是假设拿数据的时候被人会修改数据, 这样当任何人要或取数据的时候只能阻塞直到取得锁。

## 公平锁和非公平锁

公平锁：根据申请锁的先后顺序来获得锁

非公平锁：多个线程获得锁的先后顺序不是按照申请先后顺序。有可能造成**优先级反转**或**饥饿现象**。效率比公平锁高



要点：lock默认创建非公平锁



```java
Lock lock = new ReetentLock();//默认参数false，非公平锁

Lock lock = new ReetentLock(true);//true为公平锁

lock.lock();
/*
需要上锁的代码块
*/
lock.unlock();
```



## 可重入锁 / 不可重入锁

#### 可重入锁

广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。ReentrantLock和synchronized都是可重入锁

```
synchronized void setA() throws Exception{
 Thread.sleep(1000);
 setB();
}
synchronized void setB() throws Exception{
 Thread.sleep(1000);
}
```

上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。

#### **不可重入锁**

不可重入锁，与可重入锁相反，不可递归调用，递归调用就发生死锁。看到一个经典的讲解，使用自旋锁来模拟一个不可重入锁，代码如下

```
import java.util.concurrent.atomic.AtomicReference;
public class UnreentrantLock {
 private AtomicReference<Thread> owner = new AtomicReference<Thread>();
 public void lock() {
 Thread current = Thread.currentThread();
 //这句是很经典的“自旋”语法，AtomicInteger中也有
 for (;;) {
 if (!owner.compareAndSet(null, current)) {
 return;
 }
 }
 }
 public void unlock() {
 Thread current = Thread.currentThread();
 owner.compareAndSet(current, null);
 }
}
```

## RreentrantLock和synchronzied比较

（1）synchronized是独占锁，**加锁和解锁的过程自动进行**，易于操作，但不够灵活。ReentrantLock也是独占锁，加锁和解锁的过程需要手动进行，不易操作，但非常灵活。



（2）synchronized可重入，因为加锁和解锁自动进行，不必担心最后是否释放锁；

**ReentrantLock也可重入，但加锁和解锁需要手动进行，且次数需一样，否则其他线程无法获得锁**。



（3）synchronized**不可响应中断，一个线程获取不到锁就一直等着；ReentrantLock可以相应中断**。





# Monitor



# sychronized

用于线程同步，是一个可应用于同步代码块或者是对象。

**是非公平锁 、依赖于**jvm实现

### synchronized同步锁为类
```java
        synchronized (SyncTest.class) {
		    .....
	    }
```
synchronized作用于静态方法时，跟使用类对象作为静态锁的效果是一样的
```java
class sss{
	public static synchronized void s(){
		...
	}
}
```

# volatile 

**不保证原子性。**

（可见性，线程的工作内存的操作的值可以在共享内存中读取）

1. （重要）**保证可见性**：1.每次操作都是都必须是主内存中最新的值。2。操作完都能马上刷新到内存中。

2. volatile 只能保证对单次读/写的原子性。 
3. **禁止指令重排序：**

**例如创建对象时候，初始化对象和对象指向内存地址的指令有可能被调换顺序，使用该指令重排可以初始化完对象，再让指针指向分配的空间的顺序正确，保证线程安全。**



**性能优于sychronized**

# CAS

**原子类型实现的底层原理。**



**CAS是一种无锁算法，在不使用锁的的情况下实现多线程之间的变量同步**。CAS算法涉及到三个操作数

需要读写的内存值V进行比较的值A拟写入的新值B。



（比较和替换）。compare and swap。



比较到操作的状态值之后再执行操作，结果不符合则会进行“**自旋操作**”，即循环获取等待正确比较结果。**每次比较并不是上锁，而是调用了原子操作**，跟就具体平台底层有关。



